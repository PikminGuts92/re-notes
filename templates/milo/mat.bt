// Material objects determine texturing, blending, and the effect of lighting on drawn polys.
// Super: (None)
// Ext: .mat
// C++ Class: RndMat

#ifndef IN_MILO_FILE
    #ifndef STANDALONE_FILE
        #define STANDALONE_FILE "Mat"
    #endif
#endif

#ifndef OBJECT_MAT
#define OBJECT_MAT

#include "common.bt"

typedef enum
{
    kTexWrapClamp,
    kTexWrapRepeat, // 1
    kTexBorderBlack,
    kTexBorderWhite,
    kTexWrapMirror
} TEXWRAP_ENUM;

typedef enum
{
    kTexGenNone,
    kTexGenXfm,
    kTexGenSphere,
    kTexGenProjected,
    kTexGenXfmOrigin,
    kTexGenEnviron // 5
} TEXGEN_ENUM;

// Result = src_color * src_factor + dest_color * dest_factor ?
typedef enum
{
    kBlendDest, // Equal to dest rgb color
    kBlendSrc, // Equal to src rgb color
    kBlendAdd, // Alpha
    kBlendSrcAlpha,
    kBlendSubtract,
    kBlendMultiply,
    kPreMultAlpha // 6
} BLEND_ENUM; // D3DBLEND?

typedef enum
{
    kZModeDisable,
    kZModeNormal,
    kZModeTransparent,
    kZModeForce,
    kZModeDecal // 4
} ZMODE_ENUM;

typedef struct
{
    // 2-0: Regular
    // 3-0: Idk - eyes
    // 2-2: Shiny - torsoenv
    // 3-2: Shiny - enviro, shinplates
    int unknown1; // 1-4
    TEXGEN_ENUM texGen; // 0,1,2,5
    Matrix mat; // "Transform for coordinate generation" ?
    TEXWRAP_ENUM texWrap; // 0-1
    NumString texName; // Diffuse texture
} TextureEntry;

typedef struct (SystemInfo& info, Bool super)
{
    int version; // 55 (TBRB)
    read_metadata(info, super);

    if (version <= 21)
    {
        // GH1 mats can linked to many textures
        int tex_count;
        TextureEntry textures[tex_count]<optimize=false>;
    }

    BLEND_ENUM blend; // 0, 1, 2, 3, 4, 5
    Color color;
    float alpha;

    if (version <= 21)
    {
        // This part is a mess
        // These will all be 0 when material is used for shadow?
        byte always1;
        short always0;
        int always1;
        short always0;
    
        BLEND_ENUM blend; // Only 0-4 observed?
        short always0;

        return;
    }

    // diffuse, norm, specular

    // Not sure
    Bool prelit;      // Usually true
    Bool use_environ; // Usually false

    ZMODE_ENUM z_mode; // 1 = default, 4 = reflective?
    Bool alpha_cut;
    uint alpha_threshold;
    Bool alpha_write;
    
    if (version >= 28)
    {
        TEXGEN_ENUM tex_gen;
        TEXWRAP_ENUM tex_wrap;
    }
    else
    {
        int always_1;
    }
    
    Matrix tex_xfm; // "Transform for coordinate generation"
    NumString diffuse_tex;

    NumString next_pass; // Next material for object
    Bool always_false;
    Bool always_true;

    // 1.0  0.0  0.0  0.0  10.0
    // 1.0  0.61 0.61 0.61 46.0
    float data_floats_five_1[5]; // First 4 are normalized?

    NumString norm_tex;

    int always_0;
    NumString specular_tex;

    byte data_always_0_2[8];
    Bool always_true;

    if (version <= 27)
    {
        // GH2 PS2 has less data
        Bool always_false;
        return;
    }
    else if (version == 28)
    {
        // GH2 360
        byte data_always_0_3[5];
        return;
    }

    byte data_always_0_3[10];

    Color specular_rgb;   // Multiplied by specular texture RGB
    float specular_power; // Multiplied by specular texture Alpha

    byte data_always_0_4[13];

    float data_floats_2[9];
} Mat;


#ifdef STANDALONE_FILE

if (STANDALONE_FILE == "Mat")
{
    local int obj_version = guess_version();
    local SystemInfo info;
    info.version = 25;

    if (IsBigEndian())
    {
        info.platform = X360;
    }
    else
    {
        info.platform = PS2;
        if (obj_version == 27)
        {
            info.version = 24;
        }
    }

    Mat mat(info, False);
}

#endif

#endif