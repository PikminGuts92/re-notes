// Material objects determine texturing, blending, and the effect of lighting on drawn polys.
// Super: (None)
// Ext: .mat

#ifndef IN_MILO_FILE
    #ifndef STANDALONE_FILE
        #define STANDALONE_FILE "Mat"
    #endif
#endif

#ifndef OBJECT_MAT
#define OBJECT_MAT

#include "common.bt"

typedef enum
{
    TexWrap_Clamp,
    TexWrap_Repeat // 1
} TexWrap;

typedef enum
{
    TexGen_None,
    TexGen_Xfm,
    TexGen_Sphere,
    TexGen_Projected,
    TexGen_XfmOrigin,
    TexGen_Environ // 5
} TexGen;

// Result = src_color * src_factor + dest_color * dest_factor ?
typedef enum
{
    Blend_Dest, // Equal to dest rgb color
    Blend_Src, // Equal to src rgb color
    Blend_Add, // Alpha
    Blend_SrcAlpha,
    Blend_SrcAlphaAdd,
    Blend_Subtract,
    Blend_Multiply // 6
} Blend; // D3DBLEND?

typedef enum
{
    ZMode_Disable,
    ZMode_Normal,
    ZMode_Transparent,
    ZMode_Force,
    ZMode_Decal // 4
} ZMode;

typedef struct
{
    // 2-0: Regular
    // 3-0: Idk - eyes
    // 2-2: Shiny - torsoenv
    // 3-2: Shiny - enviro, shinplates
    int unknown1; // 1-4
    TexGen texGen; // 0,1,2,5
    Matrix mat; // "Transform for coordinate generation" ?
    TexWrap texWrap; // 0-1
    NumString texName; // Diffuse texture
} TextureEntry;

typedef struct (SystemInfo& info, Bool super)
{
    int version;
    read_metadata(info, super);

    if (version <= 21)
    {
        // GH1 mats can linked to many textures
        int tex_count;
        TextureEntry textures[tex_count]<optimize=false>;
    }

    int unknown_enum; // 0, 1, 2, 3, 4, 5
    Color color;
    float alpha;
    
    if (version <= 21)
    {
        // This part is a mess
        // These will all be 0 when material is used for shadow?
        byte always1;
        short always0;
        int always1;
        short always0;
    
        Blend blend; // Only 0-4 observed?
        short always0;

        return;
    }

    // diffuse, norm, specular

    // Not sure
    Bool usually_true;
    Bool usually_false;

    int unknown_enum; // 1 = default, 4 = reflective?

    int always_0;
    Bool usually_false;
    Bool usually_false;
    
    if (version >= 28)
    {
        byte data_always_0_1[8];
    }
    else
    {
        int always_1;
    }
    
    Matrix tex_xfm; // "Transform for coordinate generation"
    NumString diffuse_tex;

    NumString next_pass; // Next material for object
    Bool always_false;
    Bool always_true;

    // 1.0  0.0  0.0  0.0  10.0
    // 1.0  0.61 0.61 0.61 46.0
    float data_floats_five_1[5]; // First 4 are normalized?

    NumString norm_tex;

    int always_0;
    NumString specular_tex;

    byte data_always_0_2[8];
    Bool always_true;

    if (version <= 27)
    {
        // GH2 PS2 has less data
        Bool always_false;
        return;
    }
    else if (version == 28)
    {
        // GH2 360
        byte data_always_0_3[5];
        return;
    }

    byte data_always_0_3[10];

    Color specular_rgb;   // Multiplied by specular texture RGB
    float specular_power; // Multiplied by specular texture Alpha

    byte data_always_0_4[13];

    float data_floats_2[9];
} Mat;


#ifdef STANDALONE_FILE

if (STANDALONE_FILE == "Mat")
{
    local int obj_version = guess_version();
    local SystemInfo info;
    info.version = 25;

    if (IsBigEndian())
    {
        info.platform = X360;
    }
    else
    {
        info.platform = PS2;
    }

    Mat mat(info, False);
}

#endif

#endif