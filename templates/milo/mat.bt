// Material objects determine texturing, blending, and the effect of lighting on drawn polys.
// Super: (None)
// Ext: .mat
// C++ Class: RndMat

#ifndef IN_MILO_FILE
    #ifndef STANDALONE_FILE
        #define STANDALONE_FILE "Mat"
    #endif
#endif

#ifndef OBJECT_MAT
#define OBJECT_MAT

#include "common.bt"

typedef enum
{
    kTexWrapClamp,
    kTexWrapRepeat, // 1
    kTexBorderBlack,
    kTexBorderWhite,
    kTexWrapMirror
} TEXWRAP_ENUM;

typedef enum
{
    kTexGenNone,
    kTexGenXfm,
    kTexGenSphere,
    kTexGenProjected,
    kTexGenXfmOrigin,
    kTexGenEnviron // 5
} TEXGEN_ENUM;

// Result = src_color * src_factor + dest_color * dest_factor ?
typedef enum
{
    kBlendDest, // Equal to dest rgb color
    kBlendSrc, // Equal to src rgb color
    kBlendAdd, // Alpha
    kBlendSrcAlpha,
    kBlendSubtract,
    kBlendMultiply,
    kPreMultAlpha // 6
} BLEND_ENUM; // D3DBLEND?

typedef enum
{
    kZModeDisable,
    kZModeNormal,
    kZModeTransparent,
    kZModeForce,
    kZModeDecal // 4
} ZMODE_ENUM;

typedef enum
{
    kStencilIgnore,
    kStencilWrite,
    kStencilTest
} STENCILMODE_ENUM;

typedef enum
{
    kShaderVariationNone,
    kShaderVariationSkin,
    kShaderVariationHair
} SHADERVARIATION_ENUM;

// Starting w/ v56
typedef enum
{
    kPerPixelOff,
    kPerPixelXbox360Only,
    kPerPixelPs3Only,
    kPerPixelAllNgPlatforms
} PERPIXEL_ENUM;

typedef struct
{
    // 2-0: Regular
    // 3-0: Idk - eyes
    // 2-2: Shiny - torsoenv
    // 3-2: Shiny - enviro, shinplates
    int unknown1; // 1-4
    TEXGEN_ENUM texGen; // 0,1,2,5
    Matrix mat; // "Transform for coordinate generation" ?
    TEXWRAP_ENUM texWrap; // 0-1
    NumString texName; // Diffuse texture
} TextureEntry;

typedef struct (SystemInfo& info, Bool super)
{
    int version; // 55 (TBRB), 56 (GDRB)
    read_metadata(info, super);

    if (version <= 21)
    {
        // GH1 mats can linked to many textures
        int tex_count;
        TextureEntry textures[tex_count]<optimize=false>;
    }

    BLEND_ENUM blend; // How to blend poly into screen
    Color color;      // Base material color
    float alpha;      // Base material alpha

    if (version <= 21)
    {
        // This part is a mess
        // These will all be 0 when material is used for shadow?
        byte always1;
        short always0;
        int always1;
        short always0;

        BLEND_ENUM blend; // Only 0-4 observed?
        short always0;

        return;
    }

    // Not sure
    Bool prelit;      // Use vertex color and alpha for base or ambient - Usually true
    Bool use_environ; // Modulate with environment ambient and lights - Usually false

    ZMODE_ENUM z_mode;   // How to read and write z-buffer
    Bool alpha_cut;      // Cut zero alpha pixels from z-buffer
    int alpha_threshold; // Alpha level below which gets cut (0-255)
    Bool alpha_write;    // Write pixel alpha to screen

    if (version >= 28)
    {
        TEXGEN_ENUM tex_gen;   // How to generate texture coordinates
        TEXWRAP_ENUM tex_wrap; // Texture mapping mode
    }
    else
    {
        int always_1;
    }

    Matrix tex_xfm;        // Transform for coordinate generation
    NumString diffuse_tex; // Base texture map, modulated with color and alpha

    NumString next_pass; // Next material for object (Mat)
    Bool intensify;      // Double the intensity of base map - Always false
    Bool cull;           // Cull backface polygons - Always true

    float emissive_multiplier; // Multiplier to apply to emission
    Color specular_rgb;        // Color to use; multiplied by specular texture RGB if present
    float specular_power;      // Power to use; multiplied by specular texture Alpha if present - 10.0-50.0 not uncommon

    NumString normal_map;   // Texture map to define lighting normals. Requires per-pixel lighting
    NumString emissive_map; // Map for self illumination
    NumString specular_map; // Texture map for specular color and power. Requires per-pixel lighting
    NumString environ_map;  // Cube texture for reflections

    if (version <= 55)
        Bool per_pixel_lit;          // Use per-pixel lighting
    else
        PERPIXEL_ENUM per_pixel_lit; // Per-pixel lighting mode for this material
    STENCILMODE_ENUM stencil_mode;   // How to read and write the stencil buffer

    if (version <= 27)
    {
        // GH2 PS2 has less data
        Bool always_false;
        return;
    }
    else if (version == 28)
    {
        // GH2 360
        byte data_always_0_3[5];
        return;
    }

    NumString fur;    // Use fur shader
    float de_normal;  // Amount to diminish normal map bumpiness, 0 is neutral, 1 is no bumps, -1 exaggerates (range: -3 to -1)
    float anisotropy; // Specular power in downward (strand) direction, 0 to disable (range: 0.0 to 100.0)

    float norm_detail_tiling;   // Texture tiling scale for the detail map
    float norm_detail_strength; // Strength of the detail map bumpiness
    NumString norm_detail_map;  // Detail map texture

    Bool point_lights; // Is the Mat lit with point lights?
    Bool proj_lights;  // Is the Mat lit with projected lights?
    Bool fog;          // Is the Mat affected by fog?
    Bool fade_out;     // Is the Mat affected its Environment's fade_out?
    Bool color_adjust; // Is the Mat affected its Environment's color adjust?

    Color rim_rgb;        // Rim lighting color; multiplied by the rim texture RGB if present
    float rim_power;      // Rim lighting power; multiplied by the rim texture Alpha if present (range: 0.0 to 64.0)
    NumString rim_map;    // Texture map that defines the rim lighting color (in the RGB channels) and power (in the Alpha channel). Requires per-pixel lighting.
    Bool rim_always_show; // When enabled, this causes the rim effect to be visible regardless of the lighting direction. This is useful when simulating materials such as cloth

    Bool screen_aligned;                   // Projected material from camera's POV
    SHADERVARIATION_ENUM shader_variation; // Select a variation on the shader to enable a new range of rendering features

    Color specular2_rgb;   // Secondary specular color. Only valid for certain shader variations
    float specular2_power; // Secondary specular power. Only valid for certain shader variations

    // Not mapped to SyncProperty()
    // Values are usually 0.0 or 1.0
    // Default: (1.0, 1.0, 1.0, 1.0, 0.0)
    float unknown_floats[5];

    NumString alpha_mask;     // Alpha mask coordinates (in widescreen) and texture (ScreenMask)
    Bool ps3_force_trilinear; // Force trilinear filtering of diffuse map (PS3 only)
} Mat;


#ifdef STANDALONE_FILE

if (STANDALONE_FILE == "Mat")
{
    local int obj_version = guess_version();
    local SystemInfo info;
    info.version = 25;

    if (IsBigEndian())
    {
        info.platform = X360;
    }
    else
    {
        info.platform = PS2;
        if (obj_version == 27)
        {
            info.version = 24;
        }
    }

    Mat mat(info, False);
}

#endif

#endif