// A Mesh object is composed of triangle faces.
// Super: Draw Trans
// Ext: .mesh
// C++ Class: RndMesh

#ifndef IN_MILO_FILE
    #ifndef STANDALONE_FILE
        #define STANDALONE_FILE "Mesh"
    #endif
#endif

#ifndef OBJECT_MESH
#define OBJECT_MESH

#include "common.bt"
#include "draw.bt"
#include "trans.bt"

struct Mesh;

string mesh_to_string(Mesh& mesh)
{
    local string s;
    SPrintf(s, "(%d verts, %d faces)", mesh.vertices.count, mesh.faces.count);
    return s;
}

typedef struct (SystemInfo& info, int mesh_version, Bool is_ng, int vert_size)
{
    // Coordinates
    float x;
    float y;
    float z;
    if (mesh_version == 34 || (mesh_version == 36 && is_ng == False && (info.platform == X360 || info.platform == PS3))) float w; // Always 0?

    if (mesh_version < 35 || is_ng == False)
    {
        if (mesh_version >= 38)
        {
            uint packed_1<format=hex>;
            float unknown_1;

            uint packed_2<format=hex>;
            float unknown_2;
        }

        // Normals
        float nx;
        float ny;
        float nz;
        if (mesh_version == 34 || (mesh_version == 36 && (info.platform == X360 || info.platform == PS3))) float nw; // Always 0?
        
        if (mesh_version >= 38)
        {
            // UVs
            float u;
            float v;

            // Weights
            float weight_0;
            float weight_1;
            float weight_2;
            float weight_3;
        }
        else
        {
            // Weights
            float weight_0;
            float weight_1;
            float weight_2;
            float weight_3;

            // UVs
            float u;
            float v;
        }

        if (mesh_version >= 34)
        {
            // Bone indices
            ushort bone_0;
            ushort bone_1;
            ushort bone_2;
            ushort bone_3;

            if (mesh_version >= 38)
            {
                uint packed_3<format=hex>;
                uint packed_4<format=hex>;
                float neg_1;
                float pos_1;
            }
            else
            {
                // Tangent? (range: -1 to 1)
                float tangent_0;
                float tangent_1;
                float tangent_2;
                float tangent_3;
            }
        }
    }
    else
    {
        local int uv_check = ReadInt();

        // Used for ui meshes?
        if (uv_check == -1)
        {
            uint always_ff_1<format=hex>;

            // UVs
            hfloat u;
            hfloat v;

            // Normals
            hfloat nx;
            hfloat ny;
            hfloat nz;

            ushort always_511;
            uint always_ff_2<format=hex>;

            // Bone indices
            ubyte bone_0; // Usually: [3, 2, 1, 0]
            ubyte bone_1;
            ubyte bone_2;
            ubyte bone_3;
        }
        else
        {
            // UVs
            hfloat u;
            hfloat v;

            // Normals
            hfloat nx;
            hfloat ny;
            hfloat nz;
            hfloat nw; // Not 100% sure, maybe some scaler for weight?

            // Weights
            ubyte weight_0; // Default: [FF, FF, FF, FF]
            ubyte weight_1;
            ubyte weight_2;
            ubyte weight_3;

            // Bone indices
            // Can all match like [5, 5, 5, 5]
            ushort bone_0; // Default: [0, 1, 2, 3]
            ushort bone_1;
            ushort bone_2;
            ushort bone_3;
        }

        // TODO: Remove this hacky workaround
        if (mesh_version == 38) FSkip(4);
    }
} Vertex<read=vertex_to_string>;

/*
NG Bone weights?
0x03 Terminator and/or bitfield?
0x17 0.1999999
0xF8 0.8000001
0xFF 1.0

99 47 198
130 56 191
203 148

01100011
00101111
11000110

10000010
00111000
10111111

11001011
10010100

*/

string vertex_to_string(Vertex& v)
{
    local string s;
    SPrintf(s, "(%.3f, %.3f, %.3f)", v.x, v.y, v.z);
    return s;
}

typedef struct
{
    ushort idx1;
    ushort idx2;
    ushort idx3;
} Face;

typedef struct
{
    int sectionCount;
    int vertCount;
    int sections[sectionCount]; // Ascending, last being equal to count of verts
    ushort vertOffsets[vertCount];
} GroupSection;

typedef struct (SystemInfo& info, int mesh_version)
{
    int count;
    local Bool use_ng_verts = False; // Is next gen?
    local int vert_size_loc = 0;

    if (mesh_version >= 36)
    {
        Bool is_ng; //  0 = wii, 1 = ps3/xbox

        if (is_ng == True)
        {
            // TBRB/GDRB (36, 1)
            // RB3 (40, 2)
            int vert_size;
            int some_type;

            use_ng_verts = True;
            vert_size_loc = vert_size;
        }
    }

    local int i = 0;
    while (i < count)
    {
        Vertex verts(info, mesh_version, use_ng_verts, vert_size_loc);
        i++;
    }
} Vertices;

typedef struct
{
    int count;

    local int i = 0;
    while (i < count)
    {
        Face faces;
        i++;
    }    
} Faces;

typedef struct
{
    NumString bone_name;
    Matrix mat;
} BoneTrans;

typedef enum
{
    kMutableNone = 0,
    kMutableVerts = 31,
    kMutableFaces = 32,
    kMutableAll = 63
} MUTABLE_ENUM;

typedef enum
{
    kVolumeEmpty,
    kVolumeTriangles,
    kVolumeBSP,
    kVolumeBox
} VOLUME_ENUM;

typedef struct (SystemInfo& info, Bool super)
{
    int version; // 25 (KRPAI/GH1), 28 (GH2/GH2 4-song), 29, 34 (GH2 360/RB1/RB2), 36 (TBRB), 37 (GDRB), 38 (RB3)

    // Read meta if newer than GH1
    if (version > 25)
    {
        read_metadata(info, super);
    }

    Trans trans(info, True);
    Draw draw(info, True);

    NumString mat;        // Material used for rendering the Mesh (Mat)
    NumString geom_owner; // Geometry owner for the mesh (Mesh)
    
    MUTABLE_ENUM mutable; // Bitfield? 0, 31, 33, 37, 63
    VOLUME_ENUM volume; // Volume of the Mesh (usually kVolumeTriangles)
    byte bsp; // Never observed, always 0

    Vertices vertices(info, version);
    Faces faces;
    
    // Weight groups?
    int groupSizesCount;
    if (groupSizesCount > 0) ubyte groupSizes[groupSizesCount]; // Sum should equal count of faces
    
    local int charCount = ReadInt();
    
    if (charCount > 0)
    {
        if (version >= 34) // Starting w/ RB1
        {
            // Array of bone transform objects for n-bones
            int bone_count;
            BoneTrans bones[bone_count]<optimize=false>;
        }
        else
        {
            // Always 4 bones (some can be empty)
            NumString bones[4]<optimize=false>;
            Matrix boneTransforms[4];
        }
    }
    else
    {
        int noBones; // Always 0
    }

    if (version >= 36)
    {
        Bool keep_mesh_data; // Whether or not to keep mesh vertices and faces.  Mutable meshes will always keep this data.
    }

    if (version == 37)
    {
        Bool exclude_from_self_shadow; // Whether to include this mesh in a parent Character's self-shadow generation or not.
    }
    else if (version >= 38)
    {
        Bool has_ao_calculation; // Whether or not this mesh has had ambient occlusion calculated on it.
    }
    
    // This seems to be a last gen or lower version thing...
    // Present when groupSize count is at least one and at least one bone?
    if (groupSizesCount > 0 && groupSizes[0] > 0 && info.version < 25)
    {
        // If eof, then groups should be divided equally? Empty only for light meshes?
        GroupSection groups[groupSizesCount]<optimize=false>;
    }
} Mesh<read=mesh_to_string>;

#ifdef STANDALONE_FILE

if (STANDALONE_FILE == "Mesh")
{
    local int obj_version = guess_version();
    local SystemInfo info;
    info.version = 25;

    if (IsBigEndian())
    {
        info.platform = X360;
    }
    else
    {
        info.platform = PS2;
        if (obj_version <= 28)
        {
            info.version = 24;
        }
    }

    Mesh mesh(info, False);
}

#endif

#endif