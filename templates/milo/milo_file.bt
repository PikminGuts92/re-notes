#ifndef MILO_FILE
#define MILO_FILE

struct MiloFile;

#ifndef IN_MILO_FILE
    #define IN_MILO_FILE 1
#endif

#include "char_clip_set.bt"
#include "character.bt"
#include "common.bt"
#include "object_dir.bt"
#include "objects.bt"
#include "panel_dir.bt"
#include "rnd_dir.bt"
#include "world_dir.bt"
#include "world_instance.bt"

typedef struct
{
    NumString type;
    NumString name;

    local uint offset;
    local uint size;
} MiloEntry<read=read_milo_entry>;

string read_milo_entry(MiloEntry& me)
{
    local string s;
    SPrintf(s, "%s: %s", me.type.text, me.name.text);
    return s;
}

typedef struct (int milo_version)
{
    if (milo_version > 10)
    {
        NumString dir_type; // class_name
        NumString dir_name;

        // String table info for names/classes
        uint string_table_string_count;
        uint string_table_used_size;
    }

    int entry_count;
    if (entry_count > 0)
    {
        MiloEntry entries[entry_count]<optimize=false>;
    }
} MiloEntries<read=read_milo_entries>;

string read_milo_entries(MiloEntries& mes)
{
    local string s;
    
    if (exists(mes.dir_type))
    {
        SPrintf(s, "%s: %s (%d entries)", mes.dir_type.text, mes.dir_name.text, mes.entry_count);
    }
    else
    {
        SPrintf(s, "(%d entries)", mes.entry_count);
    }
    
    return s;
}

typedef struct
{
    int ext_count;
    NumString ext_paths[ext_count]<optimize=false>;
} ExternalResources<read=read_ext_resources>;


string read_ext_resources(ExternalResources& er)
{
    local string s;
    SPrintf(s, "(%d external resources)", er.ext_count);    
    return s;
}

typedef struct (MiloFile& milo, NumString& entry_type, NumString& entry_name, uint entry_offset, uint entry_size)
{
    local string type = entry_type.text;
    local string name = entry_name.text;

    local uint offset = entry_offset;
    local uint size = entry_size;

    byte data[size];
    uint padding<format=hex>;
} Blob<read=read_blob>;

string read_blob(Blob& blob)
{
    local string s;
    SPrintf(s, "%s: %s (%d bytes)", blob.type, blob.name, blob.size);    
    return s;
}

// DirLoader::SaveObjects
void read_milo_files(MiloFile& milo)
{
    local uint i;
    local uint file_size;

    for (i = 0; i < milo.meta.entry_count; i++)
    {
        switch (milo.meta.entries[i].type.text)
        {
            case "CharClipSet":
                CharClipSet dir_entry(info, False, False);
                uint padding<format=hex>;

                MiloFile sub_dirs(info);
                break;
            case "Group":
                Group group(info, False);
                uint padding<format=hex>;
                break;
            case "RndDir":
                RndDir dir_entry(info, False, False);
                uint padding<format=hex>;

                MiloFile sub_dir(info);
                break;
            case "WorldInstance":
                // Inlined so DirLoader::SaveObjects not needed
                WorldInstance dir_entry(info, False, True);

                uint padding<format=hex>;
                break;
            default:
                file_size = findNextFile(adde);
                if (file_size == -1) break;

                milo.meta.entries[i].offset = FTell();
                milo.meta.entries[i].size = file_size;

                Blob files(
                    milo,
                    milo.meta.entries[i].type,
                    milo.meta.entries[i].name,
                    milo.meta.entries[i].offset,
                    milo.meta.entries[i].size);
                break;
        }
    }
}

typedef struct (SystemInfo& info, MiloFile& milo)
{
    read_milo_files(milo);
} MiloFileEntries;

typedef struct (SystemInfo& info)
{
    int version;
    MiloEntries meta(version);

    if (version <= 10)
    {
        // Used in GH1-era games
        // Paths usually reference external textures
        // Note: Can be collection of nulls
        ExternalResources ext_resources;
    }
    else
    {
        switch (meta.dir_type.text)
        {
            case "Character":
                Character dir_entry(info, False, False);
                uint padding<format=hex>;
                break;
            case "CharClipSet":
                CharClipSet dir_entry(info, False, False);
                uint padding<format=hex>;
                break;
            case "ObjectDir":
                ObjectDir dir_entry(info, False, False);
                uint padding<format=hex>;
                break;
            case "PanelDir":
                PanelDir dir_entry(info, False, False);
                uint padding<format=hex>;
                break;
            case "RndDir":
                RndDir dir_entry(info, False, False);
                uint padding<format=hex>;
                break;
            case "WorldDir":
                WorldDir dir_entry(info, False, False);
                uint padding<format=hex>;
                break;
            case "WorldInstance":
                WorldInstance dir_entry(info, False, True); // Inlined for some reason...
                uint padding<format=hex>;
                break;
            default:
                // Read directory entry
                local uint size = findNextFile(adde);
                Blob dir_entry(this, meta.dir_type, meta.dir_name, FTell(), size);
                break;
        }
    }

    if (meta.entry_count > 0)
    {
        MiloFileEntries children(info, this);
    }
} MiloFile;

local int milo_version = guess_version();

if (milo_version == -1)
{
    // TODO: Read magic and read block offset
    FSkip(2064);
    milo_version = guess_version();
}

local SystemInfo info;
info.version = milo_version;

MiloFile milo(info);

if (!FEof())
{
    Printf("WARNING: End of file not reached. Milo may not have been properly parsed.");
}

#endif