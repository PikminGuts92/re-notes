#ifndef FORGE_LAYER
#define FORGE_LAYER

#include "common.bt"
#include "object.bt"
#include "trans.bt"

struct Layer;

typedef struct (Bool inlined)
{
    char magic[4]; // "LAYR"
    int always_61;
    
    Bool bool_1; // Always true if .layer file? No...
    Bool bool_2; // True for layers with embedded references?

    // String table info for names/classes
    // Both 0 if no entries
    uint string_table_string_count;
    uint string_table_used_size;
    
    uint entry_count;
    
    if (entry_count > 0)
    {
        struct LayerEntryName
        {
            FString file_class;
            FString file_name;
        } layer_entry_names[entry_count]<read=Str("%s (%s)", this.file_name.text, this.file_class.text), optimize=false>;
        
        local uint i = 0;
        struct LayerEntry
        {
            local string class = layer_entry_names[i].file_class.text;
            local string name = layer_entry_names[i].file_name.text;
            i++;
            
            local uint is_layer = 0;
            switch (class)
            {
                case "CharAnimDriver":
                    is_layer = true;
                    break;
            }
            
            if (is_layer
                && ReadString(FTell(), 4) == "LAYR") // Hacky way to tell if inlined
                // neutral_skeleton.char has both inlined and non-lined CharaAnimDriver entries :(
            {
                Layer inlined_data(True);
            }
            
            // Read as regular entry
            uint64 size;
            local uint64 end_offset = FTell() + size;
            
            switch (class)
            {
                case "Object":
                    Object data;
                    break;
                case "Trans":
                    Trans data(False);
                    break;
                default:
                    byte data[size];
                    break;
            }

            // Help with in-progress templates
            if (FTell() < end_offset)
            {
                byte data_unknown[end_offset - FTell()];
            }
        } layer_entries[entry_count]<read=Str("%s (%s)", this.name, this.class), optimize=false>;
    }
    
    // No extra files if inlined as entry
    if (inlined) return;

    while (ReadUInt(FTell()) != 0)
    {
        struct EmbeddedFile
        {
            FString file_class;
            FString file_name;
            
            uint64 size;
            byte data[size];
        } embedded_files<read=Str("%s (%s)", this.file_name.text, this.file_class.text)>;
    }
    
    byte extra_unknown[12];
    
    return;
    
    uint all_zeros[4];
    
    uint always_8;
    uint unknown_4;   // 0x000
    uint unknown_5;   // 0x0E
    
    Bool always_1;
    int always_0;
    
    FString inherited; // Part of entity/reflection/group/mesh
    
    uint unknown_numbers[3];
    float some_floats[4];
    
    //12 bytes remain
} Layer;

#endif

//LittleEndian();
//Layer file;