LittleEndian();

struct Component;

typedef struct
{
    local string string_value = "";
    
    uint size;
    if (size > 0)
    {
        char value[size];
        string_value = value;
    }
} PrefixedString<read=this.string_value>;

typedef struct
{
    float x;
    float y;
    float z;
    
    byte extra_data[52];
} Vertex64<read=Str("(x = %f, y = %f, z = %f)", this.x, this.y, this.z)>;

typedef struct
{
    float x;
    float y;
    float z;

    float norm_x;
    float norm_y;
    float norm_z;
    
    float unknown_x;
    float unknown_y;
    float unknown_z;

    uint separator<format=hex>; // Always 0xffffffff

    float u_1;
    float v_1;
    float u_2;
    float v_2;

    float always_0_1;
    float always_0_2;

    uint maybe_some_index_index<format=hex>; // Usually 0xffffffff
} Vertex68<read=Str("(x = %f, y = %f, z = %f)", this.x, this.y, this.z)>;

typedef struct
{
    uint idx_1;
    uint idx_2;
    uint idx_3;

    ushort material_index;
} Face<read=Str("[%d, %d, %d] (Material #%d)", this.idx_1, this.idx_2, this.idx_3, this.material_index + 1)>;

typedef struct
{
    ushort always_0;
    uint material_count;
    
    local uint i;
    for (i = 0; i < material_count; i++)
    {
        uint unknown<hidden=true>; // Always 2
        Component materials;
    }
    
    uint vert_count;
    ushort vert_size_type;

    if (vert_count > 0)
    {
        // 1F03 = 64 bytes
        // 9F03 = 68 bytes (Rigged models)
        switch (vert_size_type)
        {
            case 0x31F:
                Vertex64 vertices[vert_count];
                break;
            case 0x39F:
                Vertex68 vertices[vert_count];
                break;
            default:
                // Log error
                Assert(false, Str("Vert size type of %X is not supported", this.vert_size_type));
                break;
        }
    }
    
    uint face_count;
    if (face_count > 0) Face faces[face_count];
} GeometryComponent<read=Str("(%d vertices, %d faces)", this.vert_count, this.face_count)>;

typedef struct
{
    ushort always_0;
    PrefixedString name;

    // Enum for transparency?
    // 10 = opaque
    uint always_10;
    float unknown_float_1;
    float spec_mul; // Not 100% sure
    float spec_exp;
    
    ushort always_0;
    
    PrefixedString diffuse_texture_path;
    PrefixedString spec_texture_path;
    PrefixedString norm_texture_path;

    byte empty_data_1[12];
    uint unknown<format=hex>; // 0xFF000000
    
    byte empty_data_2[4];
    uint unknown<format=hex>; // 0xFF000000
    
    float parallax_scale;
    float parallax_bias;
    float unknown_float_2; // Always 0.0
} MaterialComponent;

typedef struct
{
    uint weight_count;
    if (weight_count < 1) return;

    // 10 bytes
    struct Weight
    {
        uint vert_index;
        ushort bone_index;
        float value;
    } weights[weight_count]<read=Str("(vertex: %d, bone: %d, weight: %f)", this.vert_index, this.bone_index, this.value)>;
} WeightComponent;

typedef struct
{
    ushort always_0;
    
    ushort bone_count;
    if (bone_count > 0)
    {
        struct Bone
        {
            PrefixedString name;
            ushort parent_bone_index; // 0xffff if root

            // pos (xyz) + quart (xyzw)?
            float mat_1[7]; // World
            float mat_2[7]; // Local
        } bones[bone_count]<optimize=false, read=this.name.string_value>;
    }

    ushort unknown_always_0;
} SkeletonComponent;

typedef struct
{
    local string component_name = "Unknown";
    char magic_open[4];

    uint size;
    switch (magic_open)
    {
        case "MOEG":
            component_name = "Geometry";
            GeometryComponent geometry;
            break;
        case "LRTM":
            component_name = "Material";
            MaterialComponent material;
            break;
        case "THGW":
            component_name = "Weight";
            WeightComponent weight;
            break;
        case "LEKS":
            component_name = "Skeleton";
            SkeletonComponent skeleton;
            break;
        default:
            if (size > 0) byte data[size];
            break;
    }
    uint unknown; // Usually 1. 2 for Material (Element depth?)

    char magic_close[4];
} Component<read=Str("%s (%s)", this.component_name, this.magic_open)>;

typedef struct
{
    local uint has_component = ReadUInt();
    while (has_component == 1)
    {
        uint is_component<hidden=true>;
        Component components;
        
        has_component = ReadUInt();
    }

    uint has_component_terminator; // Always 0
} Components;

typedef struct
{
    char magic_open[4]; // "LDOM"
    uint size;
    //local uint end_position = FTell() + size;
    ushort always_0;
    
    Components components;
    char magic_close[4]; // "LDOM"
} Model;

typedef struct
{
    char magic[4]; // "VBIN"
    uint always_65k;
    uint always_0;
    
    Model model;
    
    uint always_ffs<format=hex>;
} VBinFile;

VBinFile file;